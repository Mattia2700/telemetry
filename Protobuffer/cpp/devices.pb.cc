// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: devices.proto

#include "devices.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace devices {
constexpr Imu::Imu(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0)
  , x_(0)
  , y_(0)
  , z_(0)
  , scale_(0){}
struct ImuDefaultTypeInternal {
  constexpr ImuDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImuDefaultTypeInternal() {}
  union {
    Imu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImuDefaultTypeInternal _Imu_default_instance_;
constexpr Encoder::Encoder(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0)
  , rads_(0)
  , km_(0)
  , rotations_(0){}
struct EncoderDefaultTypeInternal {
  constexpr EncoderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EncoderDefaultTypeInternal() {}
  union {
    Encoder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EncoderDefaultTypeInternal _Encoder_default_instance_;
constexpr Steer::Steer(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0)
  , angle_(0){}
struct SteerDefaultTypeInternal {
  constexpr SteerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SteerDefaultTypeInternal() {}
  union {
    Steer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SteerDefaultTypeInternal _Steer_default_instance_;
constexpr Pedals::Pedals(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0)
  , throttle1_(0)
  , throttle2_(0)
  , brake_front_(0)
  , brake_rear_(0){}
struct PedalsDefaultTypeInternal {
  constexpr PedalsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PedalsDefaultTypeInternal() {}
  union {
    Pedals _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PedalsDefaultTypeInternal _Pedals_default_instance_;
constexpr Inverter::Inverter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0)
  , temperature_(0)
  , motor_temp_(0)
  , torque_(0)
  , speed_(0){}
struct InverterDefaultTypeInternal {
  constexpr InverterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InverterDefaultTypeInternal() {}
  union {
    Inverter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InverterDefaultTypeInternal _Inverter_default_instance_;
constexpr Bms::Bms(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0)
  , temperature_(0)
  , max_temperature_(0)
  , current_(0)
  , voltage_(0)
  , power_(0){}
struct BmsDefaultTypeInternal {
  constexpr BmsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BmsDefaultTypeInternal() {}
  union {
    Bms _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BmsDefaultTypeInternal _Bms_default_instance_;
constexpr Ecu::Ecu(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0){}
struct EcuDefaultTypeInternal {
  constexpr EcuDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EcuDefaultTypeInternal() {}
  union {
    Ecu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EcuDefaultTypeInternal _Ecu_default_instance_;
constexpr Chimera::Chimera(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : accel_()
  , gyro_()
  , encoder_left_()
  , encoder_right_()
  , bms_lv_()
  , bms_hv_()
  , inverter_left_()
  , inverter_right_()
  , pedal_()
  , steer_()
  , ecu_(){}
struct ChimeraDefaultTypeInternal {
  constexpr ChimeraDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ChimeraDefaultTypeInternal() {}
  union {
    Chimera _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ChimeraDefaultTypeInternal _Chimera_default_instance_;
}  // namespace devices
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_devices_2eproto[8];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_devices_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_devices_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_devices_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::devices::Imu, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::devices::Imu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Imu, timestamp_),
  PROTOBUF_FIELD_OFFSET(::devices::Imu, x_),
  PROTOBUF_FIELD_OFFSET(::devices::Imu, y_),
  PROTOBUF_FIELD_OFFSET(::devices::Imu, z_),
  PROTOBUF_FIELD_OFFSET(::devices::Imu, scale_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::devices::Encoder, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::devices::Encoder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Encoder, timestamp_),
  PROTOBUF_FIELD_OFFSET(::devices::Encoder, rads_),
  PROTOBUF_FIELD_OFFSET(::devices::Encoder, km_),
  PROTOBUF_FIELD_OFFSET(::devices::Encoder, rotations_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::devices::Steer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::devices::Steer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Steer, timestamp_),
  PROTOBUF_FIELD_OFFSET(::devices::Steer, angle_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::devices::Pedals, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::devices::Pedals, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Pedals, timestamp_),
  PROTOBUF_FIELD_OFFSET(::devices::Pedals, throttle1_),
  PROTOBUF_FIELD_OFFSET(::devices::Pedals, throttle2_),
  PROTOBUF_FIELD_OFFSET(::devices::Pedals, brake_front_),
  PROTOBUF_FIELD_OFFSET(::devices::Pedals, brake_rear_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::devices::Inverter, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::devices::Inverter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Inverter, timestamp_),
  PROTOBUF_FIELD_OFFSET(::devices::Inverter, temperature_),
  PROTOBUF_FIELD_OFFSET(::devices::Inverter, motor_temp_),
  PROTOBUF_FIELD_OFFSET(::devices::Inverter, torque_),
  PROTOBUF_FIELD_OFFSET(::devices::Inverter, speed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::devices::Bms, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::devices::Bms, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Bms, timestamp_),
  PROTOBUF_FIELD_OFFSET(::devices::Bms, temperature_),
  PROTOBUF_FIELD_OFFSET(::devices::Bms, max_temperature_),
  PROTOBUF_FIELD_OFFSET(::devices::Bms, current_),
  PROTOBUF_FIELD_OFFSET(::devices::Bms, voltage_),
  PROTOBUF_FIELD_OFFSET(::devices::Bms, power_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::devices::Ecu, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::devices::Ecu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Ecu, timestamp_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, accel_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, gyro_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, encoder_left_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, encoder_right_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, bms_lv_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, bms_hv_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, inverter_left_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, inverter_right_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, pedal_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, steer_),
  PROTOBUF_FIELD_OFFSET(::devices::Chimera, ecu_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, sizeof(::devices::Imu)},
  { 15, 24, sizeof(::devices::Encoder)},
  { 28, 35, sizeof(::devices::Steer)},
  { 37, 47, sizeof(::devices::Pedals)},
  { 52, 62, sizeof(::devices::Inverter)},
  { 67, 78, sizeof(::devices::Bms)},
  { 84, 90, sizeof(::devices::Ecu)},
  { 91, -1, sizeof(::devices::Chimera)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Imu_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Encoder_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Steer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Pedals_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Inverter_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Bms_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Ecu_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::devices::_Chimera_default_instance_),
};

const char descriptor_table_protodef_devices_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rdevices.proto\022\007devices\"\213\001\n\003Imu\022\026\n\ttime"
  "stamp\030\001 \001(\002H\000\210\001\001\022\016\n\001x\030\002 \001(\002H\001\210\001\001\022\016\n\001y\030\003 "
  "\001(\002H\002\210\001\001\022\016\n\001z\030\004 \001(\002H\003\210\001\001\022\022\n\005scale\030\005 \001(\002H"
  "\004\210\001\001B\014\n\n_timestampB\004\n\002_xB\004\n\002_yB\004\n\002_zB\010\n\006"
  "_scale\"\211\001\n\007Encoder\022\026\n\ttimestamp\030\001 \001(\002H\000\210"
  "\001\001\022\021\n\004rads\030\002 \001(\002H\001\210\001\001\022\017\n\002km\030\003 \001(\002H\002\210\001\001\022\026"
  "\n\trotations\030\004 \001(\002H\003\210\001\001B\014\n\n_timestampB\007\n\005"
  "_radsB\005\n\003_kmB\014\n\n_rotations\"K\n\005Steer\022\026\n\tt"
  "imestamp\030\001 \001(\002H\000\210\001\001\022\022\n\005angle\030\002 \001(\002H\001\210\001\001B"
  "\014\n\n_timestampB\010\n\006_angle\"\314\001\n\006Pedals\022\026\n\tti"
  "mestamp\030\001 \001(\002H\000\210\001\001\022\026\n\tthrottle1\030\002 \001(\002H\001\210"
  "\001\001\022\026\n\tthrottle2\030\003 \001(\002H\002\210\001\001\022\030\n\013brake_fron"
  "t\030\004 \001(\002H\003\210\001\001\022\027\n\nbrake_rear\030\005 \001(\002H\004\210\001\001B\014\n"
  "\n_timestampB\014\n\n_throttle1B\014\n\n_throttle2B"
  "\016\n\014_brake_frontB\r\n\013_brake_rear\"\300\001\n\010Inver"
  "ter\022\026\n\ttimestamp\030\001 \001(\002H\000\210\001\001\022\030\n\013temperatu"
  "re\030\002 \001(\002H\001\210\001\001\022\027\n\nmotor_temp\030\003 \001(\002H\002\210\001\001\022\023"
  "\n\006torque\030\004 \001(\002H\003\210\001\001\022\022\n\005speed\030\005 \001(\002H\004\210\001\001B"
  "\014\n\n_timestampB\016\n\014_temperatureB\r\n\013_motor_"
  "tempB\t\n\007_torqueB\010\n\006_speed\"\351\001\n\003Bms\022\026\n\ttim"
  "estamp\030\001 \001(\002H\000\210\001\001\022\030\n\013temperature\030\002 \001(\002H\001"
  "\210\001\001\022\034\n\017max_temperature\030\003 \001(\002H\002\210\001\001\022\024\n\007cur"
  "rent\030\004 \001(\002H\003\210\001\001\022\024\n\007voltage\030\005 \001(\002H\004\210\001\001\022\022\n"
  "\005power\030\006 \001(\002H\005\210\001\001B\014\n\n_timestampB\016\n\014_temp"
  "eratureB\022\n\020_max_temperatureB\n\n\010_currentB"
  "\n\n\010_voltageB\010\n\006_power\"+\n\003Ecu\022\026\n\ttimestam"
  "p\030\001 \001(\002H\000\210\001\001B\014\n\n_timestamp\"\376\002\n\007Chimera\022\033"
  "\n\005accel\030\001 \003(\0132\014.devices.Imu\022\032\n\004gyro\030\002 \003("
  "\0132\014.devices.Imu\022&\n\014encoder_left\030\003 \003(\0132\020."
  "devices.Encoder\022\'\n\rencoder_right\030\004 \003(\0132\020"
  ".devices.Encoder\022\034\n\006bms_lv\030\005 \003(\0132\014.devic"
  "es.Bms\022\034\n\006bms_hv\030\006 \003(\0132\014.devices.Bms\022(\n\r"
  "inverter_left\030\007 \003(\0132\021.devices.Inverter\022)"
  "\n\016inverter_right\030\010 \003(\0132\021.devices.Inverte"
  "r\022\036\n\005pedal\030\t \003(\0132\017.devices.Pedals\022\035\n\005ste"
  "er\030\n \003(\0132\016.devices.Steer\022\031\n\003ecu\030\013 \003(\0132\014."
  "devices.Ecub\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_devices_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_devices_2eproto = {
  false, false, 1459, descriptor_table_protodef_devices_2eproto, "devices.proto", 
  &descriptor_table_devices_2eproto_once, nullptr, 0, 8,
  schemas, file_default_instances, TableStruct_devices_2eproto::offsets,
  file_level_metadata_devices_2eproto, file_level_enum_descriptors_devices_2eproto, file_level_service_descriptors_devices_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK ::PROTOBUF_NAMESPACE_ID::Metadata
descriptor_table_devices_2eproto_metadata_getter(int index) {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_devices_2eproto);
  return descriptor_table_devices_2eproto.file_level_metadata[index];
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_devices_2eproto(&descriptor_table_devices_2eproto);
namespace devices {

// ===================================================================

class Imu::_Internal {
 public:
  using HasBits = decltype(std::declval<Imu>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Imu::Imu(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Imu)
}
Imu::Imu(const Imu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(scale_));
  // @@protoc_insertion_point(copy_constructor:devices.Imu)
}

void Imu::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(scale_));
}

Imu::~Imu() {
  // @@protoc_insertion_point(destructor:devices.Imu)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Imu::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Imu::ArenaDtor(void* object) {
  Imu* _this = reinterpret_cast< Imu* >(object);
  (void)_this;
}
void Imu::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Imu::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Imu::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Imu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scale_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(scale_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Imu::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float z = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float scale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Imu::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Imu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float timestamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_timestamp(), target);
  }

  // float x = 2;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_x(), target);
  }

  // float y = 3;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_y(), target);
  }

  // float z = 4;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_z(), target);
  }

  // float scale = 5;
  if (_internal_has_scale()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Imu)
  return target;
}

size_t Imu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Imu)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // float timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float x = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // float y = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // float z = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // float scale = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Imu::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Imu)
  GOOGLE_DCHECK_NE(&from, this);
  const Imu* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Imu>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Imu)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Imu)
    MergeFrom(*source);
  }
}

void Imu::MergeFrom(const Imu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Imu)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      z_ = from.z_;
    }
    if (cached_has_bits & 0x00000010u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Imu::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Imu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Imu::CopyFrom(const Imu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Imu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Imu::IsInitialized() const {
  return true;
}

void Imu::InternalSwap(Imu* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Imu, scale_)
      + sizeof(Imu::scale_)
      - PROTOBUF_FIELD_OFFSET(Imu, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Imu::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Encoder::_Internal {
 public:
  using HasBits = decltype(std::declval<Encoder>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rads(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_km(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rotations(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Encoder::Encoder(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Encoder)
}
Encoder::Encoder(const Encoder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&rotations_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(rotations_));
  // @@protoc_insertion_point(copy_constructor:devices.Encoder)
}

void Encoder::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rotations_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(rotations_));
}

Encoder::~Encoder() {
  // @@protoc_insertion_point(destructor:devices.Encoder)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Encoder::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Encoder::ArenaDtor(void* object) {
  Encoder* _this = reinterpret_cast< Encoder* >(object);
  (void)_this;
}
void Encoder::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Encoder::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Encoder::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Encoder)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rotations_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(rotations_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Encoder::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float rads = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_rads(&has_bits);
          rads_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float km = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_km(&has_bits);
          km_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float rotations = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_rotations(&has_bits);
          rotations_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Encoder::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Encoder)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float timestamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_timestamp(), target);
  }

  // float rads = 2;
  if (_internal_has_rads()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_rads(), target);
  }

  // float km = 3;
  if (_internal_has_km()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_km(), target);
  }

  // float rotations = 4;
  if (_internal_has_rotations()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_rotations(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Encoder)
  return target;
}

size_t Encoder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Encoder)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // float timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float rads = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // float km = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // float rotations = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Encoder::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Encoder)
  GOOGLE_DCHECK_NE(&from, this);
  const Encoder* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Encoder>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Encoder)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Encoder)
    MergeFrom(*source);
  }
}

void Encoder::MergeFrom(const Encoder& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Encoder)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      rads_ = from.rads_;
    }
    if (cached_has_bits & 0x00000004u) {
      km_ = from.km_;
    }
    if (cached_has_bits & 0x00000008u) {
      rotations_ = from.rotations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Encoder::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Encoder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Encoder::CopyFrom(const Encoder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Encoder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Encoder::IsInitialized() const {
  return true;
}

void Encoder::InternalSwap(Encoder* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Encoder, rotations_)
      + sizeof(Encoder::rotations_)
      - PROTOBUF_FIELD_OFFSET(Encoder, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Encoder::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Steer::_Internal {
 public:
  using HasBits = decltype(std::declval<Steer>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Steer::Steer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Steer)
}
Steer::Steer(const Steer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&angle_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(angle_));
  // @@protoc_insertion_point(copy_constructor:devices.Steer)
}

void Steer::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&angle_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(angle_));
}

Steer::~Steer() {
  // @@protoc_insertion_point(destructor:devices.Steer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Steer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Steer::ArenaDtor(void* object) {
  Steer* _this = reinterpret_cast< Steer* >(object);
  (void)_this;
}
void Steer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Steer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Steer::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Steer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&angle_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(angle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Steer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float angle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_angle(&has_bits);
          angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Steer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Steer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float timestamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_timestamp(), target);
  }

  // float angle = 2;
  if (_internal_has_angle()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Steer)
  return target;
}

size_t Steer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Steer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // float timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float angle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Steer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Steer)
  GOOGLE_DCHECK_NE(&from, this);
  const Steer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Steer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Steer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Steer)
    MergeFrom(*source);
  }
}

void Steer::MergeFrom(const Steer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Steer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      angle_ = from.angle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Steer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Steer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Steer::CopyFrom(const Steer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Steer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Steer::IsInitialized() const {
  return true;
}

void Steer::InternalSwap(Steer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Steer, angle_)
      + sizeof(Steer::angle_)
      - PROTOBUF_FIELD_OFFSET(Steer, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Steer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Pedals::_Internal {
 public:
  using HasBits = decltype(std::declval<Pedals>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_throttle1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_throttle2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_brake_front(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_brake_rear(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Pedals::Pedals(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Pedals)
}
Pedals::Pedals(const Pedals& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&brake_rear_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(brake_rear_));
  // @@protoc_insertion_point(copy_constructor:devices.Pedals)
}

void Pedals::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&brake_rear_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(brake_rear_));
}

Pedals::~Pedals() {
  // @@protoc_insertion_point(destructor:devices.Pedals)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Pedals::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Pedals::ArenaDtor(void* object) {
  Pedals* _this = reinterpret_cast< Pedals* >(object);
  (void)_this;
}
void Pedals::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Pedals::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Pedals::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Pedals)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&brake_rear_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(brake_rear_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pedals::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float throttle1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_throttle1(&has_bits);
          throttle1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float throttle2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_throttle2(&has_bits);
          throttle2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float brake_front = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_brake_front(&has_bits);
          brake_front_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float brake_rear = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_brake_rear(&has_bits);
          brake_rear_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Pedals::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Pedals)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float timestamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_timestamp(), target);
  }

  // float throttle1 = 2;
  if (_internal_has_throttle1()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_throttle1(), target);
  }

  // float throttle2 = 3;
  if (_internal_has_throttle2()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_throttle2(), target);
  }

  // float brake_front = 4;
  if (_internal_has_brake_front()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_brake_front(), target);
  }

  // float brake_rear = 5;
  if (_internal_has_brake_rear()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_brake_rear(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Pedals)
  return target;
}

size_t Pedals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Pedals)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // float timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float throttle1 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // float throttle2 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // float brake_front = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // float brake_rear = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pedals::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Pedals)
  GOOGLE_DCHECK_NE(&from, this);
  const Pedals* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Pedals>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Pedals)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Pedals)
    MergeFrom(*source);
  }
}

void Pedals::MergeFrom(const Pedals& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Pedals)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      throttle1_ = from.throttle1_;
    }
    if (cached_has_bits & 0x00000004u) {
      throttle2_ = from.throttle2_;
    }
    if (cached_has_bits & 0x00000008u) {
      brake_front_ = from.brake_front_;
    }
    if (cached_has_bits & 0x00000010u) {
      brake_rear_ = from.brake_rear_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Pedals::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Pedals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pedals::CopyFrom(const Pedals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Pedals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pedals::IsInitialized() const {
  return true;
}

void Pedals::InternalSwap(Pedals* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pedals, brake_rear_)
      + sizeof(Pedals::brake_rear_)
      - PROTOBUF_FIELD_OFFSET(Pedals, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Pedals::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Inverter::_Internal {
 public:
  using HasBits = decltype(std::declval<Inverter>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_motor_temp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_torque(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Inverter::Inverter(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Inverter)
}
Inverter::Inverter(const Inverter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:devices.Inverter)
}

void Inverter::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(speed_));
}

Inverter::~Inverter() {
  // @@protoc_insertion_point(destructor:devices.Inverter)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Inverter::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Inverter::ArenaDtor(void* object) {
  Inverter* _this = reinterpret_cast< Inverter* >(object);
  (void)_this;
}
void Inverter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Inverter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Inverter::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Inverter)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(speed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Inverter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temperature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_temperature(&has_bits);
          temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float motor_temp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_motor_temp(&has_bits);
          motor_temp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float torque = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_torque(&has_bits);
          torque_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_speed(&has_bits);
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Inverter::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Inverter)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float timestamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_timestamp(), target);
  }

  // float temperature = 2;
  if (_internal_has_temperature()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_temperature(), target);
  }

  // float motor_temp = 3;
  if (_internal_has_motor_temp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_motor_temp(), target);
  }

  // float torque = 4;
  if (_internal_has_torque()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_torque(), target);
  }

  // float speed = 5;
  if (_internal_has_speed()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Inverter)
  return target;
}

size_t Inverter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Inverter)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // float timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float temperature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // float motor_temp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // float torque = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Inverter::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Inverter)
  GOOGLE_DCHECK_NE(&from, this);
  const Inverter* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Inverter>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Inverter)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Inverter)
    MergeFrom(*source);
  }
}

void Inverter::MergeFrom(const Inverter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Inverter)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      temperature_ = from.temperature_;
    }
    if (cached_has_bits & 0x00000004u) {
      motor_temp_ = from.motor_temp_;
    }
    if (cached_has_bits & 0x00000008u) {
      torque_ = from.torque_;
    }
    if (cached_has_bits & 0x00000010u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Inverter::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Inverter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Inverter::CopyFrom(const Inverter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Inverter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Inverter::IsInitialized() const {
  return true;
}

void Inverter::InternalSwap(Inverter* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Inverter, speed_)
      + sizeof(Inverter::speed_)
      - PROTOBUF_FIELD_OFFSET(Inverter, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Inverter::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Bms::_Internal {
 public:
  using HasBits = decltype(std::declval<Bms>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_current(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_voltage(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_power(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Bms::Bms(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Bms)
}
Bms::Bms(const Bms& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&power_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(power_));
  // @@protoc_insertion_point(copy_constructor:devices.Bms)
}

void Bms::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&power_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(power_));
}

Bms::~Bms() {
  // @@protoc_insertion_point(destructor:devices.Bms)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Bms::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Bms::ArenaDtor(void* object) {
  Bms* _this = reinterpret_cast< Bms* >(object);
  (void)_this;
}
void Bms::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bms::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Bms::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Bms)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&power_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(power_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bms::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temperature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_temperature(&has_bits);
          temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float max_temperature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_max_temperature(&has_bits);
          max_temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_current(&has_bits);
          current_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float voltage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_voltage(&has_bits);
          voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float power = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_power(&has_bits);
          power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Bms::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Bms)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float timestamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_timestamp(), target);
  }

  // float temperature = 2;
  if (_internal_has_temperature()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_temperature(), target);
  }

  // float max_temperature = 3;
  if (_internal_has_max_temperature()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_max_temperature(), target);
  }

  // float current = 4;
  if (_internal_has_current()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_current(), target);
  }

  // float voltage = 5;
  if (_internal_has_voltage()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_voltage(), target);
  }

  // float power = 6;
  if (_internal_has_power()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_power(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Bms)
  return target;
}

size_t Bms::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Bms)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // float timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float temperature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // float max_temperature = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // float current = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // float voltage = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // float power = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Bms::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Bms)
  GOOGLE_DCHECK_NE(&from, this);
  const Bms* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Bms>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Bms)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Bms)
    MergeFrom(*source);
  }
}

void Bms::MergeFrom(const Bms& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Bms)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      temperature_ = from.temperature_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_temperature_ = from.max_temperature_;
    }
    if (cached_has_bits & 0x00000008u) {
      current_ = from.current_;
    }
    if (cached_has_bits & 0x00000010u) {
      voltage_ = from.voltage_;
    }
    if (cached_has_bits & 0x00000020u) {
      power_ = from.power_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Bms::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Bms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Bms::CopyFrom(const Bms& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Bms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bms::IsInitialized() const {
  return true;
}

void Bms::InternalSwap(Bms* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Bms, power_)
      + sizeof(Bms::power_)
      - PROTOBUF_FIELD_OFFSET(Bms, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Bms::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Ecu::_Internal {
 public:
  using HasBits = decltype(std::declval<Ecu>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Ecu::Ecu(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Ecu)
}
Ecu::Ecu(const Ecu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  timestamp_ = from.timestamp_;
  // @@protoc_insertion_point(copy_constructor:devices.Ecu)
}

void Ecu::SharedCtor() {
timestamp_ = 0;
}

Ecu::~Ecu() {
  // @@protoc_insertion_point(destructor:devices.Ecu)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Ecu::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Ecu::ArenaDtor(void* object) {
  Ecu* _this = reinterpret_cast< Ecu* >(object);
  (void)_this;
}
void Ecu::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Ecu::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ecu::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Ecu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  timestamp_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ecu::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Ecu::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Ecu)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float timestamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Ecu)
  return target;
}

size_t Ecu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Ecu)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float timestamp = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ecu::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Ecu)
  GOOGLE_DCHECK_NE(&from, this);
  const Ecu* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Ecu>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Ecu)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Ecu)
    MergeFrom(*source);
  }
}

void Ecu::MergeFrom(const Ecu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Ecu)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_timestamp()) {
    _internal_set_timestamp(from._internal_timestamp());
  }
}

void Ecu::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Ecu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ecu::CopyFrom(const Ecu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Ecu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ecu::IsInitialized() const {
  return true;
}

void Ecu::InternalSwap(Ecu* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(timestamp_, other->timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Ecu::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class Chimera::_Internal {
 public:
};

Chimera::Chimera(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  accel_(arena),
  gyro_(arena),
  encoder_left_(arena),
  encoder_right_(arena),
  bms_lv_(arena),
  bms_hv_(arena),
  inverter_left_(arena),
  inverter_right_(arena),
  pedal_(arena),
  steer_(arena),
  ecu_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:devices.Chimera)
}
Chimera::Chimera(const Chimera& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      accel_(from.accel_),
      gyro_(from.gyro_),
      encoder_left_(from.encoder_left_),
      encoder_right_(from.encoder_right_),
      bms_lv_(from.bms_lv_),
      bms_hv_(from.bms_hv_),
      inverter_left_(from.inverter_left_),
      inverter_right_(from.inverter_right_),
      pedal_(from.pedal_),
      steer_(from.steer_),
      ecu_(from.ecu_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:devices.Chimera)
}

void Chimera::SharedCtor() {
}

Chimera::~Chimera() {
  // @@protoc_insertion_point(destructor:devices.Chimera)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Chimera::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Chimera::ArenaDtor(void* object) {
  Chimera* _this = reinterpret_cast< Chimera* >(object);
  (void)_this;
}
void Chimera::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Chimera::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Chimera::Clear() {
// @@protoc_insertion_point(message_clear_start:devices.Chimera)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  accel_.Clear();
  gyro_.Clear();
  encoder_left_.Clear();
  encoder_right_.Clear();
  bms_lv_.Clear();
  bms_hv_.Clear();
  inverter_left_.Clear();
  inverter_right_.Clear();
  pedal_.Clear();
  steer_.Clear();
  ecu_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Chimera::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .devices.Imu accel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_accel(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Imu gyro = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gyro(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Encoder encoder_left = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_encoder_left(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Encoder encoder_right = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_encoder_right(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Bms bms_lv = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bms_lv(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Bms bms_hv = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bms_hv(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Inverter inverter_left = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inverter_left(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Inverter inverter_right = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inverter_right(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Pedals pedal = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pedal(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Steer steer = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_steer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .devices.Ecu ecu = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ecu(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Chimera::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:devices.Chimera)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .devices.Imu accel = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_accel_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_accel(i), target, stream);
  }

  // repeated .devices.Imu gyro = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_gyro_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_gyro(i), target, stream);
  }

  // repeated .devices.Encoder encoder_left = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_encoder_left_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_encoder_left(i), target, stream);
  }

  // repeated .devices.Encoder encoder_right = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_encoder_right_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_encoder_right(i), target, stream);
  }

  // repeated .devices.Bms bms_lv = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bms_lv_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_bms_lv(i), target, stream);
  }

  // repeated .devices.Bms bms_hv = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bms_hv_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_bms_hv(i), target, stream);
  }

  // repeated .devices.Inverter inverter_left = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_inverter_left_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_inverter_left(i), target, stream);
  }

  // repeated .devices.Inverter inverter_right = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_inverter_right_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_inverter_right(i), target, stream);
  }

  // repeated .devices.Pedals pedal = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_pedal_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_pedal(i), target, stream);
  }

  // repeated .devices.Steer steer = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_steer_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_steer(i), target, stream);
  }

  // repeated .devices.Ecu ecu = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ecu_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_ecu(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:devices.Chimera)
  return target;
}

size_t Chimera::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:devices.Chimera)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .devices.Imu accel = 1;
  total_size += 1UL * this->_internal_accel_size();
  for (const auto& msg : this->accel_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Imu gyro = 2;
  total_size += 1UL * this->_internal_gyro_size();
  for (const auto& msg : this->gyro_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Encoder encoder_left = 3;
  total_size += 1UL * this->_internal_encoder_left_size();
  for (const auto& msg : this->encoder_left_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Encoder encoder_right = 4;
  total_size += 1UL * this->_internal_encoder_right_size();
  for (const auto& msg : this->encoder_right_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Bms bms_lv = 5;
  total_size += 1UL * this->_internal_bms_lv_size();
  for (const auto& msg : this->bms_lv_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Bms bms_hv = 6;
  total_size += 1UL * this->_internal_bms_hv_size();
  for (const auto& msg : this->bms_hv_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Inverter inverter_left = 7;
  total_size += 1UL * this->_internal_inverter_left_size();
  for (const auto& msg : this->inverter_left_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Inverter inverter_right = 8;
  total_size += 1UL * this->_internal_inverter_right_size();
  for (const auto& msg : this->inverter_right_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Pedals pedal = 9;
  total_size += 1UL * this->_internal_pedal_size();
  for (const auto& msg : this->pedal_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Steer steer = 10;
  total_size += 1UL * this->_internal_steer_size();
  for (const auto& msg : this->steer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .devices.Ecu ecu = 11;
  total_size += 1UL * this->_internal_ecu_size();
  for (const auto& msg : this->ecu_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Chimera::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:devices.Chimera)
  GOOGLE_DCHECK_NE(&from, this);
  const Chimera* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Chimera>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:devices.Chimera)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:devices.Chimera)
    MergeFrom(*source);
  }
}

void Chimera::MergeFrom(const Chimera& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:devices.Chimera)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  accel_.MergeFrom(from.accel_);
  gyro_.MergeFrom(from.gyro_);
  encoder_left_.MergeFrom(from.encoder_left_);
  encoder_right_.MergeFrom(from.encoder_right_);
  bms_lv_.MergeFrom(from.bms_lv_);
  bms_hv_.MergeFrom(from.bms_hv_);
  inverter_left_.MergeFrom(from.inverter_left_);
  inverter_right_.MergeFrom(from.inverter_right_);
  pedal_.MergeFrom(from.pedal_);
  steer_.MergeFrom(from.steer_);
  ecu_.MergeFrom(from.ecu_);
}

void Chimera::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:devices.Chimera)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chimera::CopyFrom(const Chimera& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:devices.Chimera)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chimera::IsInitialized() const {
  return true;
}

void Chimera::InternalSwap(Chimera* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  accel_.InternalSwap(&other->accel_);
  gyro_.InternalSwap(&other->gyro_);
  encoder_left_.InternalSwap(&other->encoder_left_);
  encoder_right_.InternalSwap(&other->encoder_right_);
  bms_lv_.InternalSwap(&other->bms_lv_);
  bms_hv_.InternalSwap(&other->bms_hv_);
  inverter_left_.InternalSwap(&other->inverter_left_);
  inverter_right_.InternalSwap(&other->inverter_right_);
  pedal_.InternalSwap(&other->pedal_);
  steer_.InternalSwap(&other->steer_);
  ecu_.InternalSwap(&other->ecu_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Chimera::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace devices
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::devices::Imu* Arena::CreateMaybeMessage< ::devices::Imu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Imu >(arena);
}
template<> PROTOBUF_NOINLINE ::devices::Encoder* Arena::CreateMaybeMessage< ::devices::Encoder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Encoder >(arena);
}
template<> PROTOBUF_NOINLINE ::devices::Steer* Arena::CreateMaybeMessage< ::devices::Steer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Steer >(arena);
}
template<> PROTOBUF_NOINLINE ::devices::Pedals* Arena::CreateMaybeMessage< ::devices::Pedals >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Pedals >(arena);
}
template<> PROTOBUF_NOINLINE ::devices::Inverter* Arena::CreateMaybeMessage< ::devices::Inverter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Inverter >(arena);
}
template<> PROTOBUF_NOINLINE ::devices::Bms* Arena::CreateMaybeMessage< ::devices::Bms >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Bms >(arena);
}
template<> PROTOBUF_NOINLINE ::devices::Ecu* Arena::CreateMaybeMessage< ::devices::Ecu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Ecu >(arena);
}
template<> PROTOBUF_NOINLINE ::devices::Chimera* Arena::CreateMaybeMessage< ::devices::Chimera >(Arena* arena) {
  return Arena::CreateMessageInternal< ::devices::Chimera >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
